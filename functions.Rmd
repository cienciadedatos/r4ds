# Funciones

## Introducción

Una de las mejores maneras de lograr tener mayor alcance como científica de datos es escribir funciones. Las funciones te permitirán automatizar algunas tareas comunes en una manera poderosa y general que copiar-y-pegar. Escribir funciones tiene 3 grandes ventajas sobre copiar-y-pegar:

1. Puedes dar a la función un nombre evocativo que hace to código más fácil de entender. 

2. Como cambien los requerimientos, tu solo necesitas cambiar tu código en un solo lugar, en vez de varios lugares. 

3. Tu eliminas las chances de hacer errores accidentales cuando copias y pegas (ej. actualizar el nombre de una variable en un lugar, pero no en otro).

Escribir funciones en un viaje de toda la vida. Incluso después de usar R por varios años yo aún aprendo nuevas técnicas y mejores formas de abordar viejos problemas. El objetivo de este capítulo no es enseñarte cada detalle esotérico de funciones pero sí introducirte con consejos pragmáticos que puedes aplicar inmediatamente. 

Como así también en los avisos práctivos para escribir funciones, en este capítulo también te da consejos para cómo diseñar tu código. El buen diseño del código es la correcta puntuación. Tu puedes hacerlo sin eso, pero te hará las cosas más fácil de leer! Al igual que los estilos de puntuación, hay muchas posibles variaciones. Aquí presentamos el diseño que usamos en nuestro código, pero lo más importante es ser consistente. 

### Prerequisitos

El objetivo de este capítulo es escribir funciones en R base, así no 
necesitarás paquetes extra. 

## ¿Cuándo deberías escribir una función?

Debes considerar escribir una función cuando has copiado y pegado un bloque de código más de dos veces (ej. ahora tienes tres copias del mismo código). Por ejemplo, mira a este código. Qué es lo que realiza?

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

Es posible que puedas descifrar que esto reescala cada columna para tener un rango de 0 a 1. ¿Pero has visto el error? He cometido un error copiando-y-pegando el código para `df$b`: He olvidado de cambiar `a` a `b`. Extraer código repetido en una función es una buena idea porque te previene de cometer errores como este:

Para escribir una función primero necesitas analizar el código. Cuantos inputs tiene?


```{r, eval = FALSE}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

Este código tiene un solo input `df$a`. (Si te sorprende que `TRUE` no es un input, puedes explorar el ejercicio de abajo). Para hacer los inputs mas claros, es buena idea reescribir el código usando variables temporadles con nombres generales. Aca el código solamente requiere un solo vector numérico, por lo que lo llamaré `x`:

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

Hay algo de duplicación en este código. Estamos computando el rango de datos tres veces, así que tiene razón hacerlo en un solo paso:

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

Sacando cálculos intermedios en variables nombradas es una buena práctica porque deja más claro lo que está haciendo el código. Ahora que has simplificado el código, y chequeado de que aún funciona, puedo convertirlo en una función:

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

Hay 3 pasos clasves para crear una funció nueva:

1. Necesitas elegir un __name__ para la función. Aquí he usado `rescale01` poque esta función reescala un vector para que se encuentre entre 0 y 1. 

1. Listas los inputs, o  __arguments__, a la función dentro de `function`. 
Aquí solo tenemos un argumento. Si tenemos más, la llamada se vería como `function(x, y, z)`.
1. Situas el código que has creado en __body__ de una función, un 
`{` block that immediately follows `function(...)`.

Ten en cuenta el proceso general: yo solo creo la función después de darme cuenta como funciona con una entrada simple. Es más fácil de empezar con codigo funcionando y convertirlo en una función; es más dificil de crear una función y luego intentar de hacerlo trabajar. 

En este punto es una buena idea controlar tu función con algunos inputs diferentes:

```{r}
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
```

A medida que escribas más y más funciones eventualmente querras convertir estos informales, tests interactivos en tests formales y automatizados. Este proceso se llama examen de la unidad. Desafortunadamente, esto está más allá del alcance de este libro, pero puede aprender sobre eso en <http://r-pkgs.had.co.nz/tests.html>.

Podemos simplificar el ejemplo original ahora que tenemos una función:

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

Comparado al original, este código es fácil de entender y hemos eliminado erorres del tipo copiar-y-pegar-. Esto es aún un poco de duplicación ya que estamos relizando lo mismo a diferentes columnas. Aprenderemos como eliminar esta duplicación en [iteración], una vez que hayas aprendido más sobre las estructuras de R en [vectores].


Otra ventaja de las funcioens es que nuestros requerimientos camiban, solo necesitamos hacer cambios en un solo lugar. Por ejemplo, podríamos descubrir que algunas de nuestras variables incluyen valores infinitos y `rescale01()` falla:


```{r}
x <- c(1:10, Inf)
rescale01(x)
```

Porque hemos extraído el código en una función, nosotros solo necesitamos corregirlo en un solo lugar:

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

Esta es una importante parte de "no repetirse a uno mismo" (o DRY) principio. Cuanto más repetición tengas en tu código, la mayor parte de lugares que neceistas recordar de actualizar cuando las cosas cambian (¡y esto siempre sucede!), y es más probable que crees errores (bugs) a lo largo del tiempo. 

### Práctica

1. ¿Por qué `TRUE` no es un parámetro para `rescale01()`? ¿Qué pasaría si `x` está contenido en un valor único perdido y `na.rm` fuese `FALSE`?

1. En la segunda variante de `rescale01()`, los valores infinitos se dejan sin cambio. Reescribe `rescale01()` así `-Inf` is convertido a 0, y `Inf` es convertido a 1.
    
1. Practica convertir los siguientes fragmentos de código en funciones. Piensa en lo que hace cada función. ¿Cómo lo llamarías? ¿Cuántos argumentos necesita? ¿Puedes reescribirlo para ser más expresivo o menos duplicado?

    ```{r, eval = FALSE}
    mean(is.na(x))
    
    x / sum(x, na.rm = TRUE)
    
    sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
    ```

1.  Sigue <http://nicercode.github.io/intro/writing-functions.html> 
para escribir tus propias funciones para computar la variancia y el sesgo de un vector numérico. 

1.  Escribe `both_na()`, una función que toma dos vectores de la misma longitud y retorna el número de posiciones que tiene `NA` en ambos vectores. 

1. ¿Qué hacen las siguientes funciones? ¿Por qué son tan útiles aún cuando son tan cortas?
    
    ```{r}
    is_directory <- function(x) file.info(x)$isdir
    is_readable <- function(x) file.access(x, 4) == 0
    ```

1.  Lee el [complete lyrics](https://en.wikipedia.org/wiki/Little_Bunny_Foo_Foo) 
    de "Pequeño conejito Foo Foo". There's a lot of duplication in this song. 
    Extiende el ejemplo inicial de pipes para recrear la canción completa, usar las funciones para reducir la duplicación. 


## Las funciones son para los humanos y las computadoras

Es importante recordar que las funciones no son solo para las computadoras, sino también para los seres humanos. A R no le importa el nombre de tu función ni los comentarios que tiene, pero si serán importantes para los humanos que la lean. En esta sección se discutirán algunas cosas que debes tener en mente a la hora de escribir funciones entendibles para los humanos. 

The name of a function is important. Ideally, the name of your function will be short, but clearly evoke what the function does. That's hard! But it's better to be clear than short, as RStudio's autocomplete makes it easy to type long names.

Generalmente, los nombres de las funciones deberían ser verbos, y los argumentos sustantivos. Hay algunas excepciones: usar un sustantivo es correcto si la función computa el valor de un sustantivo muy conocido (ejemplo:  mean() — (del inglés media) es mejor que compute_mean()— (del inglés computar media)),  o accede a alguna propiedad del objeto (ejemplo: coef()— (abreviatura del inglés coeficientes)  es mejor que get_coefficients()— (del inglés obtener coeficientes) ). Una buena señal de que un sustantivo puede ser una mejor elección es analizar si estás usando un verbo muy amplio como  “obtener”, “computar”, “calcular” o “determinar”. Utiliza tu mejor criterio y no tengas miedo de renombrar tu función si encuentras un nombre mejor más tarde. 

```{r, eval = FALSE}
# Too short
f()

# Not a verb, or descriptive
my_awesome_function()

# Long, but clear
impute_missing()
collapse_years()
```

Si el nombre de tu función está compuesto por múltiples palabras, recomiendo usar “caso\_serpiente”, donde cada palabra en minúscula está separada por un guión bajo. Otra alternativa popular  es caso Camello. No importa realmente cual elijas, lo importante es que seas consistente: elije una o la otra y quédate con ella. R mismo no es muy consistente, pero no hay nada que tú puedas hacer con respecto a eso. Asegúrate de no caer en la misma trampa haciendo tu código lo más consistente posible. 

```{r, eval = FALSE}
# Never do this!
col_mins <- function(x, y) {}
rowMaxes <- function(y, x) {}
```

Si tienes una familia de funciones que hacen cosas similares, asegúrate de que tengan nombres y argumentos consistentes. Usa un prefijo común para indicar que están conectadas. Eso es mejor que usar un sufijo común, ya que el predictivo te permite escribir el prefijo y ver todos los otros miembros de la familia. 

```{r, eval = FALSE}
# Good
input_select()
input_checkbox()
input_text()

# Not so good
select_input()
checkbox_input()
text_input()
```

Un buen ejemplo de este diseño es el paquete stringr: si no recuerdas exactamente que función necesitas, puedes escribir `str_`y refrescar tu memoria. 
Siempre que sea posible, evita anular funciones y variables pre-existentes. Es imposible hacer esto en general, ya que hay un montón de nombres buenos que ya han sido utilizados por otros paquetes. De todas maneras, evitar el uso de los nombres más comunes de R base te ahorrará confusiones.

```{r, eval = FALSE}
# ¡No hagas esto!
T <- FALSE
c <- 10
mean <- function(x) sum(x)
```

Usa comentarios, líneas que comienzan con `#`, para explicar el “porqué” de tu código. En general deberías evitar comentarios que expliquen el “qué” y el “cómo”. Si no se entiende que es lo que hace el código leyéndolo, deberías pensar cómo reescribirlo de manera que sea más claro.  ¿Necesitamos agregar algunas variables intermedias con nombres útiles? ¿Deberíamos dividir una función larga en subcomponentes para que pueda ser nombrada?. Sin embargo,  tu código nunca podrá capturar la razón detrás de tus decisiones: ¿Por qué elegiste este enfoque frente a otras alternativas?,  ¿Qué otra cosa probaste que no funcionó?. Es una gran idea capturar este tipo de pensamientos en un comentario. 

Otro uso importante de los comentarios es para dividir tu archivo en partes de modo que resulte más fácil de leer. Utiliza líneas largas de`-` y `=` para que resulte más fácil detectar los fragmentos. 


```{r, eval = FALSE}
# Load data --------------------------------------

# Plot data --------------------------------------
```

RStudio proporciona un abreviado de teclado para crear estos encabezados  (Cmd/Ctrl + Shift + R), y te los muestra en el menú desplegable de navegación de código en la parte inferior izquierda del editor:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("screenshots/rstudio-nav.png")
```

### Ejercicios

1.  Lee el código fuente para cada una de las siguientes tres funciones,     interpreta que hacen, y luego propone nombres mejores. 
    
    ```{r}
    f1 <- function(string, prefix) {
      substr(string, 1, nchar(prefix)) == prefix
    }
    f2 <- function(x) {
      if (length(x) <= 1) return(NULL)
      x[-length(x)]
    }
    f3 <- function(x, y) {
      rep(y, length.out = length(x))
    }
    ```
    
1.  Toma una función que hayas escrito recientemente y tómate 5 minutos para pensar un mejor nombre para la función y para sus argumentos. 

1.  Compara y contrasta `rnorm()` y `MASS::mvrnorm()`. ¿Cómo podrías hacerlas más consistentes? 
    
1.  Argumenta porqué `norm_r()`,`norm_d()` etc sería una mejor opción que `rnorm()`, `dnorm()`. Argumenta lo contrario.

## Ejecución condicional

Una sentencia `if`le permite ejecutar un código condicional. Por ejemplo:

```{r, eval = FALSE}
if (condition) {
  # code executed when condition is TRUE
} else {
  # code executed when condition is FALSE
}
```

Para obtener ayuda en `if` necesitas ponerlo entre comillas simples: `` ?`if` ``. La ayuda no es especialmente útil si aún no eres un programador experimentado ¡Pero al menos puedes saber cómo llegar a ella!

Aquí se presenta una función simple que utiliza una sentencia `if`. El objetivo de esta función es devolver un vector lógico que describa si se nombra o no cada elemento de un vector.

```{r}
has_name <- function(x) {
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !is.na(nms) & nms != ""
  }
}
```

Esta función aprovecha la regla de retorno estándar: una función devuelve el último valor que calculó. Este es uno de los dos usos de la declaración `if`.

### Condiciones

La condición debe evaluar a `TRUE` o `FALSE`. Si es un vector, recibirás un mensaje de advertencia; si es una `NA`, obtendrás un error. Tenga cuidado con estos mensajes en su propio código:

```{r, error = TRUE}
if (c(TRUE, FALSE)) {}

if (NA) {}
```

Puedes usar `||` (o) y `&&`(y) para combinar múltiples expresiones lógicas. Estos operadores están "haciendo cortocircuito": tan pronto como `||` ve el primer `TRUE` devuelve `TRUE` sin calcular nada más. Tan pronto como && vea el primer `FALSE`, devuelve `FALSE`. Nunca debes usar`|`o `&` en una sentencia `if`: estas son operaciones vectorizadas que se aplican a valores múltiples (es por eso que las usas en `filter()`). Si tienes un vector lógico, puede usar `any()` o `all()` para juntarlo en un único valor.

Be careful when testing for equality. `==` is vectorised, which means that it's easy to get more than one output.  Either check the length is already 1, collapse with `all()` or `any()`, or use the non-vectorised `identical()`. `identical()` is very strict: it always returns either a single `TRUE` or a single `FALSE`, and doesn't coerce types. This means that you need to be careful when comparing integers and doubles:

Tenga cuidado al probar la igualdad.`==` está vectorizado, lo que significa que es fácil obtener más de una salida. Compruebe si la longitud ya es 1, colapse con `all()` o `any()`, o usa el no vectorizado `identical()`. `identical()` es muy estricto: siempre devuelve un solo `TRUE` o un solo `FALSE`, y no coacciona tipos. Esto significa que debe tener cuidado al comparar enteros y dobles:

```{r}
identical(0L, 0)
```

You also need to be wary of floating point numbers:

```{r}
x <- sqrt(2) ^ 2
x
x == 2
x - 2
```

En su lugar use `dplyr::near()` para comparaciones, como se describe en [comparisons].

Y recuerde, `x == NA` ¡No hace nada útil!

### Condiciones múltiples

Puede encadenar múltiples sentencias if juntas:

```{r, eval = FALSE}
if (this) {
  # do that
} else if (that) {
  # do something else
} else {
  # 
}
```

Pero si terminas con una larga serie de sentencias`if` encadenadas, deberías considerar reescribir. Una técnica útil es la función `switch()` . Esta le permite evaluar el código seleccionado según la posición o el nombre.

```{r, echo = FALSE}
function(x, y, op) {
  switch(op,
    plus = x + y,
    minus = x - y,
    times = x * y,
    divide = x / y,
    stop("Unknown op!")
  )
}
```

Otra función útil que a menudo puede eliminar largas cadenas de sentencias `if`es `cut()`. Esta es utilizada para discretizar variables continuas.

### Estilo de código

Ambas sentencias `if` y `function` deberían (casi) siempre ir entre llaves (`{}`), y el contenido debería estar seguido de dos espacios. Esto hace que sea más fácil ver la jerarquía en su código en el margen izquierdo.

La llave de apertura nunca debe ir en su propia línea y siempre debe ir seguida de una nueva línea. Una llave de cierre siempre debe ir en su propia línea, a menos que sea seguida por `else`. Siempre agregar espacio en el código dentro de las llaves. 

```{r, eval = FALSE}
# Good
if (y < 0 && debug) {
  message("Y is negative")
}

if (y == 0) {
  log(x)
} else {
  y ^ x
}

# Bad
if (y < 0 && debug)
message("Y is negative")

if (y == 0) {
  log(x)
} 
else {
  y ^ x
}
```

Estaría bien evitar las llaves si tienes una sentencia `if` muy corta que pueda caber en una línea:

```{r}
y <- 10
x <- if (y < 20) "Too low" else "Too high"
```

Esto se recomienda solo para sentencias `if` muy breves. De lo contrario, la sentencia completa es más fácil de leer:

```{r}
if (y < 20) {
  x <- "Too low" 
} else {
  x <- "Too high"
}
```

### Ejercicios

1. ¿Cuál es la diferencia entre `if` and `ifelse()`? Lea cuidadosamente la ayuda y construya tres      ejemplos que ilustren las diferencias claves.
    

1.  Escriba una función de saludo que diga "buenos días", "buenas tardes" o "buenas noches", según      la hora del día. (Sugerencia: use un argumento de tiempo que por defecto es `lubridate::now()`,     eso hará que sea más fácil probar su función).

1.  Implemente una función `fizzbuzz`. Toma un solo número como entrada. Si el número es divisible      por tres, devuelve "fizz". Si es divisible por cinco, devuelve "buzz". Si es divisible por tres     y cinco, devuelve "fizzbuzz". De lo contrario, devuelve el número. Asegúrese de escribir primero     el código de trabajo antes de crear la función.
    
1.  ¿Cómo podría usar `cut()` para simplificar una sentencia if-else anidada?

    ```{r, eval = FALSE}
    if (temp <= 0) {
      "freezing"
    } else if (temp <= 10) {
      "cold"
    } else if (temp <= 20) {
      "cool"
    } else if (temp <= 30) {
      "warm"
    } else {
      "hot"
    }
    ```
  
    ¿Cómo cambiarías la sentencia a `cut()` si hubieras usado `<`en lugar de `<=`? ¿Cuál es la otra     ventaja principal de `cut()` para este problema? (Sugerencia: ¿qué sucede si tienes muchos          valores en  `temp`?)

1.  ¿Qué sucedería si usaras `switch()` con un valor numérico?

1.  ¿Qué haría la sentencia `switch()`? ¿Qúe sucedería si `x` fuera “e”?

    ```{r, eval = FALSE}
    switch(x, 
      a = ,
      b = "ab",
      c = ,
      d = "cd"
    )
    ```
    
    Experimente, luego lea cuidadosamente la documentación.


## Function arguments

The arguments to a function typically fall into two broad sets: one set supplies the __data__ to compute on, and the other supplies arguments that control the __details__ of the computation. For example:

* In `log()`, the data is `x`, and the detail is the `base` of the logarithm.

* In `mean()`, the data is `x`, and the details are how much data to trim
  from the ends (`trim`) and how to handle missing values (`na.rm`).

* In `t.test()`, the data are `x` and `y`, and the details of the test are
  `alternative`, `mu`, `paired`, `var.equal`, and `conf.level`.
  
* In `str_c()` you can supply any number of strings to `...`, and the details
  of the concatenation are controlled by `sep` and `collapse`.
  
Generally, data arguments should come first. Detail arguments should go on the end, and usually should have default values. You specify a default value in the same way you call a function with a named argument:

```{r}
# Compute confidence interval around mean using normal approximation
mean_ci <- function(x, conf = 0.95) {
  se <- sd(x) / sqrt(length(x))
  alpha <- 1 - conf
  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}

x <- runif(100)
mean_ci(x)
mean_ci(x, conf = 0.99)
```

The default value should almost always be the most common value. The few exceptions to this rule are to do with safety. For example, it makes sense for `na.rm` to default to `FALSE` because missing values are important. Even though `na.rm = TRUE` is what you usually put in your code, it's a bad idea to silently ignore missing values by default.

When you call a function, you typically omit the names of the data arguments, because they are used so commonly. If you override the default value of a detail argument, you should use the full name:

```{r, eval = FALSE}
# Good
mean(1:10, na.rm = TRUE)

# Bad
mean(x = 1:10, , FALSE)
mean(, TRUE, x = c(1:10, NA))
```

You can refer to an argument by its unique prefix (e.g. `mean(x, n = TRUE)`), but this is generally best avoided given the possibilities for confusion.

Notice that when you call a function, you should place a space around `=` in function calls, and always put a space after a comma, not before (just like in regular English). Using whitespace makes it easier to skim the function for the important components.

```{r, eval = FALSE}
# Good
average <- mean(feet / 12 + inches, na.rm = TRUE)

# Bad
average<-mean(feet/12+inches,na.rm=TRUE)
```

### Choosing names

The names of the arguments are also important. R doesn't care, but the readers of your code (including future-you!) will. Generally you should prefer longer, more descriptive names, but there are a handful of very common, very short names. It's worth memorising these:

* `x`, `y`, `z`: vectors.
* `w`: a vector of weights.
* `df`: a data frame.
* `i`, `j`: numeric indices (typically rows and columns).
* `n`: length, or number of rows.
* `p`: number of columns.

Otherwise, consider matching names of arguments in existing R functions. For example, use `na.rm` to determine if missing values should be removed.

### Checking values

As you start to write more functions, you'll eventually get to the point where you don't remember exactly how your function works. At this point it's easy to call your function with invalid inputs. To avoid this problem, it's often useful to make constraints explicit. For example, imagine you've written some functions for computing weighted summary statistics:

```{r}
wt_mean <- function(x, w) {
  sum(x * w) / sum(w)
}
wt_var <- function(x, w) {
  mu <- wt_mean(x, w)
  sum(w * (x - mu) ^ 2) / sum(w)
}
wt_sd <- function(x, w) {
  sqrt(wt_var(x, w))
}
```

What happens if `x` and `w` are not the same length?

```{r}
wt_mean(1:6, 1:3)
```

In this case, because of R's vector recycling rules, we don't get an error. 

It's good practice to check important preconditions, and throw an error (with `stop()`), if they are not true:

```{r}
wt_mean <- function(x, w) {
  if (length(x) != length(w)) {
    stop("`x` and `w` must be the same length", call. = FALSE)
  }
  sum(w * x) / sum(w)
}
```

Be careful not to take this too far. There's a tradeoff between how much time you spend making your function robust, versus how long you spend writing it. For example, if you also added a `na.rm` argument, I probably wouldn't check it carefully:

```{r}
wt_mean <- function(x, w, na.rm = FALSE) {
  if (!is.logical(na.rm)) {
    stop("`na.rm` must be logical")
  }
  if (length(na.rm) != 1) {
    stop("`na.rm` must be length 1")
  }
  if (length(x) != length(w)) {
    stop("`x` and `w` must be the same length", call. = FALSE)
  }
  
  if (na.rm) {
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(w)
}
```

This is a lot of extra work for little additional gain. A useful compromise is the built-in `stopifnot()`: it checks that each argument is `TRUE`, and produces a generic error message if not.

```{r, error = TRUE}
wt_mean <- function(x, w, na.rm = FALSE) {
  stopifnot(is.logical(na.rm), length(na.rm) == 1)
  stopifnot(length(x) == length(w))
  
  if (na.rm) {
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(w)
}
wt_mean(1:6, 6:1, na.rm = "foo")
```

Note that when using `stopifnot()` you assert what should be true rather than checking for what might be wrong.

### Dot-dot-dot (...)

Many functions in R take an arbitrary number of inputs:

```{r}
sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
stringr::str_c("a", "b", "c", "d", "e", "f")
```

How do these functions work? They rely on a special argument: `...` (pronounced dot-dot-dot). This special argument captures any number of arguments that aren't otherwise matched. 

It's useful because you can then send those `...` on to another function. This is a useful catch-all if your function primarily wraps another function. For example, I commonly create these helper functions that wrap around `str_c()`:

```{r}
commas <- function(...) stringr::str_c(..., collapse = ", ")
commas(letters[1:10])

rule <- function(..., pad = "-") {
  title <- paste0(...)
  width <- getOption("width") - nchar(title) - 5
  cat(title, " ", stringr::str_dup(pad, width), "\n", sep = "")
}
rule("Important output")
```

Here `...` lets me forward on any arguments that I don't want to deal with to `str_c()`. It's a very convenient technique. But it does come at a price: any misspelled arguments will not raise an error. This makes it easy for typos to go unnoticed:

```{r}
x <- c(1, 2)
sum(x, na.mr = TRUE)
```

If you just want to capture the values of the `...`, use `list(...)`.

### Lazy evaluation

Arguments in R are lazily evaluated: they're not computed until they're needed. That means if they're never used, they're never called. This is an important property of R as a programming language, but is generally not important when you're writing your own functions for data analysis. You can read more about lazy evaluation at <http://adv-r.had.co.nz/Functions.html#lazy-evaluation>.

### Exercises

1.  What does `commas(letters, collapse = "-")` do? Why?

1.  It'd be nice if you could supply multiple characters to the `pad` argument, 
    e.g. `rule("Title", pad = "-+")`. Why doesn't this currently work? How 
    could you fix it?
    
1.  What does the `trim` argument to `mean()` do? When might you use it?

1.  The default value for the `method` argument to `cor()` is 
    `c("pearson", "kendall", "spearman")`. What does that mean? What 
    value is used by default?

## Valores de salida

Darse cuenta qué es lo que tu función debería devolver suele ser bastante directo: ¡es el porqué de crear la función en primer lugar! Hay dos cosas que debes considerar al devolver un valor: 

1. ¿Devolver un valor antes, hace que tu función sea más fácil de leer?  

2. 2.	¿Puedes hacer tu función pipeable?

### Sentencias explícitas de salida

El valor de salida de una función suele ser la última sentencia que esta evalúa, pero puedes optar por devolver algo anticipadamente haciendo uso de la función `return()` ( del inglés devolución). Yo creo que es mejor reservar el uso de la función `return()` para los casos en donde es posible devolver anticipadamente una solución más simple. Una razón común para hacer esto es por ejemplo que los argumentos estén vacíos:   

```{r}
complicated_function <- function(x, y, z) {
  if (length(x) == 0 || length(y) == 0) {
    return(0)
  }
    
  # Complicated code here
}

```

Otra razón puede ser porque tienes una sentencia `if`  con un bloque complicado y uno sencillo. Por ejemplo, podrías escribir una sentencia if de esta manera: 

```{r, eval = FALSE}
f <- function() {
  if (x) {
    # Do 
    # something
    # that
    # takes
    # many
    # lines
    # to
    # express
  } else {
    # return something short
  }
}
```

Pero si el primer bloque es muy largo, para cuando llegas al `else`, ya te has olvidado la `condition`.  Una forma de reescribir esto es usar una salida anticipada para el caso sencillo: 

```{r, eval = FALSE}

f <- function() {
  if (!x) {
    return(something_short)
  }

  # Do 
  # something
  # that
  # takes
  # many
  # lines
  # to
  # express
}
```

Esto permite hacer el código más fácil de entender, ya que no necesitas tanto contexto para interpretarlo. 

### Writing pipeable functions

Si quieres escribir tus propias funciones pipeables, es importante que pienses sobre los valores de salida. Conocer el tipo de objeto de tu valor de salida significará que tu línea pipeable funciona.  Por ejemplo, en dplyr y tidyr el tipo de objeto es un data frame.

Hay dos tipos básicos de funciones pipeables: transformaciones y de efectos secundarios.  En las __transformations__, se ingresa un objeto como primer argumento y luego se devuelve una versión modificada del mismo. En el caso de __side-effects__, el objeto ingresado no es modificado sino que la función actúa sobre el objeto. Un ejemplo sería dibujar un gráfico o guardar un archivo.  Las funciones de efectos secundarios deben “invisibilizar” el primer argumento, de forma que mientras no sean impresos puedan seguir siendo usados en una línea pipeable. Por ejemplo, esta función imprime el número de valores faltantes en un data frame: 

```{r}
show_missings <- function(df) {
  n <- sum(is.na(df))
  cat("Missing values: ", n, "\n", sep = "")
  
  invisible(df)
}
```

Si la llamamos de manera interactiva, el comando `invisible()` significa que el valor de entrada `df` no se imprime:  

```{r}
show_missings(mtcars)
```

Pero sigue estando ahí, solamente que no se imprime por default:

```{r}
x <- show_missings(mtcars) 
class(x)
dim(x)
```

Y todavía podemos usarlo en un pipe:

```{r, include = FALSE}
library(dplyr)
```
```{r}
mtcars %>% 
  show_missings() %>% 
  mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>% 
  show_missings() 
```

## Entorno

El último componente de una función es su entorno. Esto no es algo que debes entender profundamente cuando tu empieas a escribir funciones. Sin embargo, es importante saber un poco acerca de entornos porque es crucial para que algunas funciones trabajen. El entorno de una función controal como R encuentra el valor asociado con un nombre. Por ejemplo, la siguiente función:

```{r}
f <- function(x) {
  x + y
} 
```

En muchos lenguajes de programación, esto sería un error, porque `y` no está definido dentro de la función. En R, esto es un código válido ya que R usa reglas llamadas __lexical scoping__ para encontrar el valor asociado a un nombre. Como `y` no está definido dentro de la función, R mirará dentro del __environment__ donde la función fue definida:

```{r}
y <- 100
f(10)

y <- 1000
f(10)
```

Este comportamiento parece una receta para errores, y de hecho debes evitar crear funciones como esta deliberadamente, pero en general no causa demasiados problemas (especialmente si reinicias regularmente R para llegar a un borrón y cuenta nueva). La ventaja de este comportamiento es que, desde el punto de vista del lenguaje, permite que R sea muy consistente. Cada nombre es buscado usando el mismo conjunto de reglas. Para `f()`incluye el comportamiento de dos cosas que podrías no esperar: `{` y `+`. Esto permite hacer cosas tortuosas como la siguiente:

```{r}
`+` <- function(x, y) {
  if (runif(1) < 0.1) {
    sum(x, y)
  } else {
    sum(x, y) * 1.1
  }
}
table(replicate(1000, 1 + 2))
rm(`+`)
```

Hay un fenómeno común en R. R pone algunos límites a tu poder. 
Puedes hacer cosas que no podrías en otro lenguaje de programación. 
Puedes hacer cosas que el 99% de las veces son extremadamente desacertadas (¡como ignorar como funciona la adición!). Pero esta flexibilidad es lo que hace que herramientas como ggplot2 y dplyr sea posible. Aprender de como hacer el mejor uso de esta flexibilidad está mas allá del alcance de este libro, pero puedes leer al respecto en [_Advanced R_](http://adv-r.had.co.nz).
